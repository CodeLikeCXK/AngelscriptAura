# 在UE里，当以 Dedicated Server 的方式启动时，Server 的 PlayerController 里 InputComponent 为什么是 nullptr?

在Unreal Engine (UE)中，以Dedicated Server方式启动时，Server的PlayerController里InputComponent为`nullptr`的原因主要是因为Dedicated Server通常没有处理客户端的输入的需求。以下是更详细的解释：

### 1. Dedicated Server 的工作模式
- **Dedicated Server**是一个专门用于处理游戏逻辑和同步游戏状态的服务器。它没有渲染和播放声音的职责，也不处理直接的玩家输入。
- 服务器主要负责游戏逻辑的执行和管理多个客户端之间的通信和状态同步。

### 2. PlayerController和InputComponent的关系
- **PlayerController**是客户端和服务器端共享的类，用于控制玩家的角色和处理输入。
- **InputComponent**是一个组件，主要用于处理玩家的输入事件（键盘、鼠标、手柄等）。在客户端，这些输入事件会被捕获并传递给InputComponent，然后通过PlayerController来控制角色的行为。

### 3. InputComponent在Dedicated Server上的表现
- 由于Dedicated Server不直接处理玩家输入，它不需要在服务器端创建和维护InputComponent。所有的玩家输入事件都是通过网络从客户端传送到服务器端的。
- 因此，在Dedicated Server模式下，PlayerController中的InputComponent通常是未初始化的（即`nullptr`）。这是一种优化和设计上的选择，因为服务器不需要占用资源去管理输入组件。

### 典型的使用场景
- **在客户端**：PlayerController会创建并管理InputComponent，以响应和处理用户输入。
- **在服务器端**：PlayerController不会创建InputComponent，因为没有实际的输入需要处理。服务器处理的是从客户端传来的输入数据包，而不是本地资源。

### 解决方法和注意事项
- 如果在Dedicated Server模式下访问InputComponent，你应该首先检查是否在服务器环境中：
    ```cpp
    if (!IsRunningDedicatedServer())
    {
        // 可以安全地访问和操作InputComponent
        InputComponent = CreateDefaultSubobject<UInputComponent>(TEXT("InputComponent"));
        // 进一步的初始化
    }
    ```
- 确保你的代码逻辑明确地区分了客户端和服务器角色，并在适当的位置进行资源和功能的初始化。

通过这样，确保在不同的运行环境下程序的行为都是预期的，并能合理地利用资源和处理逻辑。

# UE 这种把客户端和服务端代码混在一起的模式，是不是一种糟糕的设计模式？这好像违背了非常多的软件设计原则，比如高内聚低耦合、KISS、单一职责等等。
在Unreal Engine（UE）中，客户端和服务器代码混在一起的情况确实会引发一些关于软件设计原则的讨论。以下是对此设计模式的分析，包括其优缺点和实现背景。

### 优点

1. **简化开发流程**：
   - 在同一个代码库中处理客户端和服务器代码，可以简化同步逻辑和数据的一致性管理。开发者只需维护一份代码，大大减少了重复工作和数据模型的不一致问题。

2. **快速迭代**：
   - 单一代码库方便快速迭代和测试。团队可以在一个开发环境中调试和优化，不需要在不同的项目或库之间来回切换。

3. **同步更新**：
   - 客户端和服务器端的功能和修复可以同步发布，减少了兼容性问题和版本管理的复杂性。

### 缺点

1. **代码冗余度和可读性**：
   - 混合代码会变得复杂，增加了维护的难度，特别是当项目规模庞大时。理解和调试代码也会更加困难。

2. **职责分离不清晰**：
   - 违反了单一职责原则（Single Responsibility Principle），因为同一个类可能同时承担了处理客户端逻辑和服务器逻辑的职责。

3. **高耦合性**：
   - 客户端和服务器逻辑的高耦合使得模块化和重构变得困难，降低了代码的复用性和扩展性。

4. **潜在安全性问题**：
   - 客户端和服务器混合代码可能会引发潜在的安全问题。例如，如果安全关键代码也混杂在客户端，可能会被反编译或破解。

### 为什么UE选择这种设计方式

1. **历史背景**：
   - UE发展过程中，为了支持大多数游戏开发需求（尤其是复杂的多人游戏），选择了这种设计方式。它兼顾了性能优化和开发效率。

2. **整体架构考虑**：
   - UE2至UE4的演进过程中，为了实现高效的数据同步和网络通信，并减少客户端和服务器逻辑之间的一致性问题，决定采用这套混合体系。

3. **引擎广泛适用性**：
   - 为了能支持从单机到多人在线游戏的广泛场景，相同的代码库结构使得引擎对不同游戏模式更通用，开发者可以很容易地从单机模式转到多人模式，而无需重构大部分代码。

### 解决方案和折衷

尽管UE采用了这种混合设计，但开发者在实际项目中可以进行一些调整：

1. **代码注释和文档**：
   - 明确标识哪些代码是服务器端专用，哪些是客户端专用，并在注释中进行详细说明。

2. **命名约定**：
   - 使用明确的命名约定来区分客户端和服务器逻辑。例如，前缀带有`Client_`和`Server_`的函数名称。

3. **模块化设计**：
   - 在项目中，尽量模块化设计，将纯粹的客户端逻辑和服务器逻辑放置在不同的模块中，减少相互之间的依赖性。

4. **代码审查和测试**：
   - 通过严格的代码审查和测试流程，确保混合代码的质量和可维护性。

5. **条件编译**：
   - 通过条件编译（例如`#if WITH_SERVER_CODE`），在特定编译环境下启用或禁用特定代码块，增强代码的可读性和可维护性。

总之，虽然UE的这种设计模式存在一定的权衡取舍，但它是针对具体开发需求和现实环境做出的选择。理解其背后的动机和应用场景，可以更好地利用UE进行游戏开发，同时通过一定的调整和改进提高代码质量和维护效率。